> 内容来源于：[https://liaoxuefeng.com/books/java/collection/set/index.html](https://liaoxuefeng.com/books/java/collection/set/index.html)

我们知道，Map是用来存储键值映射的。对于作为键的对象，不允许重复，并且需要正确覆写`equals()`方法和`hashCode()`方法。

如果我们只需要存储不重复的键，而不需要对应的值，就可以使用Set。

Set用于存储一组不重复的元素，主要提供了以下方法：

* 向Set<E>添加元素：`boolean add(E e)`
* 从Set<E>删除元素：`boolean remove(Object e)`
* 判断元素是否存在：`boolean contains(Object e)`

让我们来看几个简单的例子：

```java
import java.util.*;

public class Main {
    public static void main(String[] args) {
        Set<String> set = new HashSet<>();
        System.out.println(set.add("abc")); // true
        System.out.println(set.add("xyz")); // true
        System.out.println(set.add("xyz")); // false, 添加失败，因为元素已存在
        System.out.println(set.contains("xyz")); // true, 元素存在
        System.out.println(set.contains("XYZ")); // false, 元素不存在
        System.out.println(set.remove("hello")); // false, 删除失败，因为元素不存在
        System.out.println(set.size()); // 2, 共有2个元素
    }
}
```

Set本质上就是只存储键的Map，没有对应的值。我们经常用Set来去除重复元素。

由于放入Set的元素和Map的键类似，都必须正确实现`equals()`和`hashCode()`方法；否则，元素无法正确放入Set。

最常用的Set实现类是`HashSet`。实际上，`HashSet`只是对`HashMap`的一个简单封装，它的核心代码如下：

```java
public class HashSet<E> implements Set<E> {
    // 持有一个HashMap:
    private HashMap<E, Object> map = new HashMap<>();

    // 放入HashMap的值:
    private static final Object PRESENT = new Object();

    public boolean add(E e) {
        return map.put(e, PRESENT) == null;
    }

    public boolean contains(Object o) {
        return map.containsKey(o);
    }

    public boolean remove(Object o) {
        return map.remove(o) == PRESENT;
    }
}
```

Set接口不保证顺序，而SortedSet接口保证元素是有序的：

* `HashSet`是无序的，因为它实现了Set接口，但没有实现SortedSet接口；
* `TreeSet`是有序的，因为它实现了SortedSet接口。

用图表示如下：

```
       ┌───┐
       │Set│
       └───┘
         ▲
    ┌────┴─────┐
    │          │
┌───────┐ ┌─────────┐
│HashSet│ │SortedSet│
└───────┘ └─────────┘
               ▲
               │
          ┌─────────┐
          │ TreeSet │
          └─────────┘
```

让我们看看HashSet的输出：

```java
import java.util.*;

public class Main {
    public static void main(String[] args) {
        Set<String> set = new HashSet<>();
        set.add("apple");
        set.add("banana");
        set.add("pear");
        set.add("orange");
        for (String s : set) {
            System.out.println(s);
        }
    }
}
```

注意输出的顺序既不是添加的顺序，也不是String的排序顺序，而且在不同的JDK版本中，这个顺序可能不同。

当把HashSet改为TreeSet后，遍历时输出的顺序就是有序的了。这个顺序就是元素的排序顺序：

```java
import java.util.*;

public class Main {
    public static void main(String[] args) {
        Set<String> set = new TreeSet<>();
        set.add("apple");
        set.add("banana");
        set.add("pear");
        set.add("orange");
        for (String s : set) {
            System.out.println(s);
        }
    }
}
```

使用TreeSet和使用TreeMap的要求一样：需要添加的元素必须正确实现Comparable接口，如果没实现Comparable接口，创建TreeSet时必须传入一个Comparator对象。