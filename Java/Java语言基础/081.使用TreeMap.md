> 内容来源于：[https://liaoxuefeng.com/books/java/collection/tree-map/index.html](https://liaoxuefeng.com/books/java/collection/tree-map/index.html)


我们已经知道，`HashMap`是一种用空间换时间的映射表，它的实现原理决定了内部的Key是无序的，即遍历`HashMap`的Key时，其顺序是不可预测的（但每个Key都会被遍历一次且仅遍历一次）。

还有一种Map，它在内部会对Key进行排序，这种Map就是`SortedMap`。注意，`SortedMap`是接口，它的实现类是`TreeMap`。

```
       ┌───┐
       │Map│
       └───┘
         ▲
    ┌────┴─────┐
    │          │
┌───────┐ ┌─────────┐
│HashMap│ │SortedMap│
└───────┘ └─────────┘
               ▲
               │
          ┌─────────┐
          │ TreeMap │
          └─────────┘
```

`SortedMap`保证了在遍历时，Key按照顺序进行排列。例如，输入的Key是`"apple"`、`"pear"`、`"orange"`，则遍历的顺序一定是`"apple"`、`"orange"`、`"pear"`，因为`String`默认按字母序排列：

```java
import java.util.*;

public class Main {
    public static void main(String[] args) {
        Map<String, Integer> map = new TreeMap<>();
        map.put("orange", 1);
        map.put("apple", 2);
        map.put("pear", 3);
        for (String key : map.keySet()) {
            System.out.println(key);
        }
        // apple, orange, pear
    }
}
```

使用`TreeMap`时，输入的Key必须实现`Comparable`接口。像`String`、`Integer`这些类已经实现了`Comparable`接口，所以可以直接作为Key。作为Value的对象则没有要求。

如果作为Key的类没有实现`Comparable`接口，那么必须在创建`TreeMap`时指定自定义排序算法：

```java
import java.util.*;

public class Main {
    public static void main(String[] args) {
        Map<Person, Integer> map = new TreeMap<>(new Comparator<Person>() {
            public int compare(Person p1, Person p2) {
                return p1.name.compareTo(p2.name);
            }
        });
        map.put(new Person("Tom"), 1);
        map.put(new Person("Bob"), 2);
        map.put(new Person("Lily"), 3);
        for (Person key : map.keySet()) {
            System.out.println(key);
        }
        // {Person: Bob}, {Person: Lily}, {Person: Tom}
        System.out.println(map.get(new Person("Bob"))); // 2
    }
}

class Person {
    public String name;
    Person(String name) {
        this.name = name;
    }
    public String toString() {
        return "{Person: " + name + "}";
    }
}
```

注意，Comparator接口要求实现一个比较方法，负责比较输入的两个元素a和b。如果a<b，则返回负数，通常是-1；如果a==b，则返回0；如果a>b，则返回正数，通常是1。TreeMap就是根据比较结果来对Key进行内部排序的。

从上述代码的执行结果可以看出，打印的Key确实是按照Comparator定义的顺序来排列的。如果要根据Key查找Value，可以传入一个新的`Person("Bob")`作为Key，它会返回对应的Integer值2。

另外，注意Person类没有覆写equals()和hashCode()，因为TreeMap不使用equals()和hashCode()。

我们来看一个稍微复杂点的例子：这次我们定义一个Student类，按分数排序，分数高的在前：

```java
import java.util.*;

public class Main {
    public static void main(String[] args) {
        Map<Student, Integer> map = new TreeMap<>(new Comparator<Student>() {
            public int compare(Student p1, Student p2) {
                return p1.score > p2.score ? -1 : 1;
            }
        });
        map.put(new Student("Tom", 77), 1);
        map.put(new Student("Bob", 66), 2);
        map.put(new Student("Lily", 99), 3);
        for (Student key : map.keySet()) {
            System.out.println(key);
        }
        System.out.println(map.get(new Student("Bob", 66))); // null?
    }
}

class Student {
    public String name;
    public int score;
    Student(String name, int score) {
        this.name = name;
        this.score = score;
    }
    public String toString() {
        return String.format("{%s: score=%d}", name, score);
    }
}
```

在for循环中，我们确实得到了正确的顺序。但是等等！当通过相同的Key查找：`new Student("Bob", 66)`时，结果却是null！

发生了什么？是TreeMap出了问题吗？当遇到异常的TreeMap行为时，我们首先应该回顾Java基本编程规则：出现问题时，不要怀疑Java标准库，而是在自己的代码中找原因。

在这个例子中，TreeMap的问题实际上是由这个Comparator引起的：

```java
public int compare(Student p1, Student p2) {
    return p1.score > p2.score ? -1 : 1;
}
```

当p1.score和p2.score不相等时，它的返回值是正确的，但当p1.score和p2.score相等时，它并没有返回0！这就是为什么TreeMap工作不正常的原因：TreeMap在比较两个Key是否相等时，依赖的是Key的compareTo()方法或Comparator.compare()方法。当两个Key相等时，必须返回0。因此，修改代码如下：

```java
public int compare(Student p1, Student p2) {
    if (p1.score == p2.score) {
        return 0;
    }
    return p1.score > p2.score ? -1 : 1;
}
```

或者直接使用`Integer.compare(int, int)`来返回正确的比较结果。

注意

使用TreeMap时，必须严格按照compare()规范实现Key的比较逻辑，相等、大于、小于！