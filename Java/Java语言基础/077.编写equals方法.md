> 内容来源于：[https://liaoxuefeng.com/books/java/collection/equals/index.html](https://liaoxuefeng.com/books/java/collection/equals/index.html)

我们知道，List是一种有序链表：List内部按照放入元素的先后顺序存放，每个元素都可以通过索引确定自己的位置。

List还提供了`boolean contains(Object o)`方法来判断List是否包含指定元素。此外，`int indexOf(Object o)`方法可以返回某个元素的索引，如果元素不存在则返回-1。

让我们来看个例子：

```java
import java.util.List;

public class Main {
    public static void main(String[] args) {
        List<String> list = List.of("A", "B", "C");
        System.out.println(list.contains("C")); // true
        System.out.println(list.contains("X")); // false
        System.out.println(list.indexOf("C")); // 2
        System.out.println(list.indexOf("X")); // -1
    }
}
```

这里我们需要考虑一个问题：我们添加到List的"C"和调用`contains("C")`时传入的"C"，是同一个实例吗？

如果这两个"C"不是同一个实例，这段代码还能得到正确的结果吗？我们可以改写代码来测试一下：

```java
import java.util.List;

public class Main {
    public static void main(String[] args) {
        List<String> list = List.of("A", "B", "C");
        System.out.println(list.contains(new String("C"))); // true or false?
        System.out.println(list.indexOf(new String("C"))); // 2 or -1?
    }
}
```

由于我们传入的是`new String("C")`，这肯定是不同的实例。结果仍然符合我们的期望——为什么？

因为List内部并不是使用`==`来判断两个元素是否相等，而是使用`equals()`方法来判断两个元素是否相等。例如，`contains()`方法可以这样实现：

```java
public class ArrayList {
    Object[] elementData;
    public boolean contains(Object o) {
        for (int i = 0; i < elementData.length; i++) {
            if (o.equals(elementData[i])) {
                return true;
            }
        }
        return false;
    }
}
```

因此，要正确使用List的`contains()`，`indexOf()`等方法，放入的实例必须正确覆写`equals()`方法，否则，放入的实例将无法被正确地识别。我们可以正常放入`String`，`Integer`等对象，是因为这些由Java标准库提供的类已经正确实现了`equals()`方法。

让我们用Person对象来测试一下：

```java
import java.util.List;

public class Main {
    public static void main(String[] args) {
        List<Person> list = List.of(
            new Person("Xiao Ming"),
            new Person("Xiao Hong"),
            new Person("Bob")
        );
        System.out.println(list.contains(new Person("Bob"))); // false
    }
}

class Person {
    String name;
    public Person(String name) {
        this.name = name;
    }
}
```

果然，尽管我们放入了`new Person("Bob")`，却无法用另一个`new Person("Bob")`找到它。原因就是Person类没有覆写`equals()`方法。

## 编写equals()

如何正确编写`equals()`方法？`equals()`方法要求我们实现以下条件：

* 自反性：对于非null的x，`x.equals(x)`必须返回true
* 对称性：对于非null的x和y，如果`x.equals(y)`为true，则`y.equals(x)`也必须为true
* 传递性：对于非null的x、y和z，如果`x.equals(y)`为true且`y.equals(z)`也为true，则`x.equals(z)`也必须为true
* 一致性：对于非null的x和y，只要x和y的内部状态不变，`x.equals(y)`始终返回true或始终返回false
* 与null比较：`x.equals(null)`总是返回false

这些规则乍一看可能非常复杂，但在代码中实现`equals()`方法实际上非常简单。我们以Person类为例：

```java
public class Person {
    public String name;
    public int age;
}
```

首先，我们需要定义"相等"的逻辑含义。对于Person类来说，如果name相等，且age相等，我们就认为这两个Person实例是相等的。

因此，编写`equals()`方法如下：

```java
public boolean equals(Object o) {
    if (o instanceof Person p) {
        return this.name.equals(p.name) && this.age == p.age;
    }
    return false;
}
```

对于引用类型字段比较，我们使用`equals()`，对于基本类型字段比较，我们使用`==`。

如果`this.name`为null，则`equals()`方法会抛出错误，所以我们需要进一步修改如下：

```java
public boolean equals(Object o) {
    if (o instanceof Person p) {
        boolean nameEquals = false;
        if (this.name == null && p.name == null) {
            nameEquals = true;
        }
        if (this.name != null) {
            nameEquals = this.name.equals(p.name);
        }
        return nameEquals && this.age == p.age;
    }
    return false;
}
```

如果Person有几个引用类型字段，上述写法就过于复杂了。为了简化引用类型的比较，我们使用`Objects.equals()`静态方法：

```java
public boolean equals(Object o) {
    if (o instanceof Person p) {
        return Objects.equals(this.name, p.name) && this.age == p.age;
    }
    return false;
}
```

因此，我们可以总结正确的编写`equals()`方法的方式：

1. 首先确定实例相等的逻辑含义，即哪些字段相等就认为实例相等
2. 使用`instanceof`判断要比较的Object是否为当前类型，如果是则继续比较，否则返回false
3. 引用类型比较使用`Objects.equals()`，基本类型比较直接使用`==`

使用`Objects.equals()`来比较两个引用类型相等的目的是为了避免对null的判断造成麻烦。当两个引用类型都为null时，也被认为是相等的。

如果你不调用List的`contains()`，`indexOf()`等方法，那么放入的元素就不需要实现`equals()`方法。